# üì¶ Variables et D√©clarations

{% hint style="info" %}
**Niveau :** üü¢ D√©butant | **Dur√©e :** 45 min | **Pr√©requis :** Introduction √† JavaScript
{% endhint %}

## üéØ Objectifs d'apprentissage

{% hint style="success" %}
√Ä la fin de cette le√ßon, vous serez capable de :
- [ ] **Comprendre** les diff√©rences entre `var`, `let` et `const`
- [ ] **Choisir** le bon type de d√©claration selon le contexte
- [ ] **Identifier** les probl√®mes de port√©e (scope)
- [ ] **Appliquer** les bonnes pratiques de d√©claration
{% endhint %}

## üîë Concepts cl√©s

{% tabs %}
{% tab title="D√©finitions" %}
**Variable** : Conteneur nomm√© pour stocker des donn√©es  
**D√©claration** : Action de cr√©er une variable  
**Port√©e (Scope)** : Zone o√π une variable est accessible  
**Hoisting** : M√©canisme de remont√©e des d√©clarations  
**Mutation** : Modification du contenu d'une variable  
{% endtab %}

{% tab title="Importance" %}
üì¶ **Stockage de donn√©es** : Fondement de tout programme  
üîß **√âviter les bugs** : Bonne d√©claration = code fiable  
üéØ **Port√©e claire** : Contr√¥ler l'acc√®s aux variables  
‚ú® **Code moderne** : Utiliser les bonnes pratiques ES6+  
üõ°Ô∏è **S√©curit√©** : Pr√©venir les erreurs de r√©assignation  
{% endtab %}
{% endtabs %}

## üìö Les trois fa√ßons de d√©clarer

### üé≠ Vue d'ensemble

{% hint style="warning" %}
**JavaScript moderne** utilise principalement `let` et `const`. `var` est conserv√© pour la compatibilit√© mais **d√©conseill√©** dans le nouveau code.
{% endhint %}

{% tabs %}
{% tab title="Comparaison rapide" %}
| Aspect | `var` | `let` | `const` |
|--------|-------|-------|---------|
| **√âpoque** | üï∞Ô∏è Ancien | ‚ú® Moderne | ‚ú® Moderne |
| **Port√©e** | Fonction | Bloc | Bloc |
| **Hoisting** | ‚ö†Ô∏è Oui | ‚ö†Ô∏è TDZ | ‚ö†Ô∏è TDZ |
| **Red√©claration** | ‚úÖ Autoris√©e | ‚ùå Interdite | ‚ùå Interdite |
| **R√©assignation** | ‚úÖ Autoris√©e | ‚úÖ Autoris√©e | ‚ùå Interdite |
| **Recommandation** | üö´ √âviter | ‚úÖ Variables | ‚úÖ Constantes |
{% endtab %}

{% tab title="R√®gle d'or moderne" %}
En JavaScript moderne, il existe une r√®gle simple √† retenir : **commencez toujours par `const`** ! Cette r√®gle vous √©vitera beaucoup d'erreurs et rendra votre code plus pr√©visible.

**Pourquoi cette r√®gle fonctionne-t-elle si bien ?**
- `const` vous oblige √† r√©fl√©chir : "Est-ce que cette valeur va vraiment changer ?"
- Si la valeur ne change pas ‚Üí parfait, gardez `const`
- Si la valeur doit changer ‚Üí utilisez `let` au lieu de `const`

Voici comment appliquer cette r√®gle dans la pratique :

```javascript
// ü•á Commencez par const pour tout
const nom = "Alice";
const age = 25;
const hobbies = ["lecture", "jardinage"];

// ü•à Changez vers let seulement si n√©cessaire
let compteur = 0;
compteur++; // Ici on modifie, donc let √©tait le bon choix

let statut = "en cours";
statut = "termin√©"; // Ici aussi on change, donc let

// üö´ N'utilisez jamais var en JavaScript moderne
```

**L'ordre de priorit√© √† retenir :**
1. ü•á `const` par d√©faut (90% des cas)
2. ü•à `let` si vous devez modifier la variable (10% des cas)
3. üö´ `var` jamais (0% des cas en code moderne)
{% endtab %}
{% endtabs %}

## üîí const : Variables constantes

### üìã Principe de base

{% hint style="info" %}
**`const` = constante :** Une fois d√©clar√©e, la variable ne peut pas √™tre **r√©assign√©e**. Parfait pour les valeurs qui ne changent pas.
{% endhint %}

{% tabs %}
{% tab title="Utilisation correcte" %}
Le mot-cl√© `const` est parfait pour toutes les valeurs qui ne vont pas changer. Pensez-y comme √† un coffre-fort : une fois qu'on y met quelque chose, on ne peut plus le changer !

**Quand utiliser `const` :**
- Pour stocker votre nom, votre √¢ge, des informations fixes
- Pour les calculs math√©matiques (comme PI = 3.14159)
- Pour les fonctions que vous cr√©ez
- Pour les objets et tableaux (m√™me si vous pouvez modifier leur contenu)

Voici des exemples concrets de bonne utilisation :

```javascript
// ‚úÖ Informations personnelles fixes
const nom = "Alice";
const age = 25;
const PI = 3.14159;
const estMajeur = true;

// ‚úÖ Objets et tableaux - la "bo√Æte" ne change pas, mais le contenu oui
const personne = {
    nom: "Bob",
    age: 30
};

const fruits = ["pomme", "banane", "orange"];

// ‚úÖ Fonctions - cr√©√©es une fois, utilis√©es partout
const saluer = function(nom) {
    return `Bonjour ${nom} !`;
};

const calculerAire = (rayon) => PI * rayon * rayon;

console.log(saluer("Alice"));        // "Bonjour Alice !"
console.log(calculerAire(5));        // 78.53975
```
{% endtab %}

{% tab title="Erreurs courantes" %}
M√™me si `const` semble simple, il y a quelques pi√®ges √† √©viter ! Voici les erreurs les plus fr√©quentes que font les d√©butants :

**Erreur #1 : Essayer de changer une constante**
Une fois qu'une variable `const` est cr√©√©e, vous ne pouvez pas lui donner une nouvelle valeur. C'est comme essayer de changer votre date de naissance - impossible !

**Erreur #2 : Oublier de donner une valeur**
Contrairement √† `let`, vous DEVEZ donner une valeur √† une variable `const` d√®s que vous la cr√©ez.

**Erreur #3 : Confusion avec les objets**
Attention ! `const` emp√™che de changer la variable elle-m√™me, mais pas le contenu des objets ou tableaux.

Regardons ces erreurs en d√©tail :

```javascript
// ‚ùå ERREUR #1 : R√©assignation interdite
const nom = "Alice";
// nom = "Bob";  // ‚ö†Ô∏è ERREUR ! TypeError: Assignment to constant variable

// ‚ùå ERREUR #2 : D√©claration sans valeur
// const vide;  // ‚ö†Ô∏è ERREUR ! SyntaxError: Missing initializer

// ‚ùå ERREUR #3 : Red√©claration interdite
const couleur = "rouge";
// const couleur = "bleu";  // ‚ö†Ô∏è ERREUR ! Cette variable existe d√©j√†

// ‚úÖ MAIS : Vous pouvez modifier le CONTENU des objets
const utilisateur = { nom: "Alice", age: 25 };
utilisateur.age = 26;  // ‚úÖ OK ! On change le contenu, pas la bo√Æte
utilisateur.ville = "Paris";  // ‚úÖ OK ! On ajoute dans la bo√Æte

console.log(utilisateur);  // { nom: "Alice", age: 26, ville: "Paris" }

// ‚ùå Mais changer toute la bo√Æte est interdit :
// utilisateur = { nom: "Bob" };  // ‚ö†Ô∏è ERREUR ! TypeError
```
{% endtab %}

{% tab title="Cas pratiques" %}
Maintenant que vous comprenez `const`, voyons dans quelles situations concr√®tes vous devriez l'utiliser. Ces exemples vous montrent les cas les plus courants dans de vrais programmes :

**1. Valeurs fixes et constantes**
Utilisez `const` pour toutes les valeurs qui ne changent jamais, comme les taxes, les limites, ou les tailles d'√©cran.

**2. Messages et URLs**
Pour tous les textes fixes de votre application, comme les messages d'accueil ou les adresses de sites web.

**3. Configuration d'applications**
Pour organiser les param√®tres de votre programme dans un seul endroit.

**4. Fonctions**
Toutes vos fonctions peuvent √™tre stock√©es dans des variables `const`.

**5. √âl√©ments HTML**
Une fois que vous trouvez un bouton ou un formulaire sur votre page, stockez-le dans une `const`.

```javascript
// 1. Valeurs num√©riques fixes
const TAUX_TVA = 0.20;
const MAX_TENTATIVES = 3;
const LARGEUR_ECRAN = 1920;

// 2. Messages et URLs
const MESSAGE_BIENVENUE = "Bienvenue sur notre site !";
const URL_API = "https://api.monsite.com";
const VERSION = "1.2.3";

// 3. Configuration d'application
const CONFIG = {
    theme: "sombre",
    langue: "fr",
    notifications: true
};

// 4. Fonctions
const formaterDate = (date) => {
    return date.toLocaleDateString('fr-FR');
};

const validerEmail = (email) => {
    return email.includes('@') && email.includes('.');
};

// 5. √âl√©ments HTML (une fois trouv√©s)
const boutonSubmit = document.getElementById('submit');
const formulaire = document.querySelector('#monFormulaire');
```
{% endtab %}
{% endtabs %}

## üîÑ let : Variables modifiables

### üìã Principe de base

{% hint style="info" %}
**`let` = variable modifiable :** Peut √™tre r√©assign√©e mais respecte la port√©e de bloc. Utilis√© quand la valeur doit changer au cours du programme.
{% endhint %}

{% tabs %}
{% tab title="Utilisation typique" %}
Le mot-cl√© `let` est parfait quand vous savez que la valeur de votre variable va changer au cours de votre programme. Pensez-y comme √† un carnet o√π vous pouvez effacer et r√©√©crire !

**Quand utiliser `let` :**
- Pour les compteurs (qui augmentent ou diminuent)
- Pour les variables qui changent selon des conditions (if/else)
- Pour accumuler des r√©sultats (comme additionner des nombres)
- Pour g√©rer des √©tats temporaires (connect√©/d√©connect√©, actif/inactif)

**Pourquoi `let` est mieux que `var` :**
`let` respecte les "blocs" de code (les accolades {}), ce qui √©vite des bugs bizarres !

Voici des exemples concrets o√π `let` est le bon choix :

```javascript
// 1. Compteurs et boucles
let compteur = 0;
for (let i = 0; i < 5; i++) {
    compteur += i;
    console.log(`Tour ${i}, compteur: ${compteur}`);
}
console.log(`Total final: ${compteur}`); // 10

// 2. Variables qui changent selon l'heure
let message;
const heure = new Date().getHours();

if (heure < 12) {
    message = "Bonjour !";
} else if (heure < 18) {
    message = "Bon apr√®s-midi !";
} else {
    message = "Bonsoir !";
}

console.log(message);

// 3. Accumuler des donn√©es
let resultat = 0;
const nombres = [1, 2, 3, 4, 5];

for (const nombre of nombres) {
    resultat += nombre; // On additionne chaque nombre
}

console.log(`Somme: ${resultat}`); // 15

// 4. √âtats qui changent
let estConnecte = false;
let tentatives = 0;

function seConnecter(motDePasse) {
    tentatives++;
    if (motDePasse === "secret123") {
        estConnecte = true;
        console.log("Connexion r√©ussie !");
    } else {
        console.log(`√âchec. Tentative ${tentatives}`);
    }
}
```
{% endtab %}

{% tab title="Port√©e de bloc" %}
Voici l'une des diff√©rences les plus importantes entre `let` et l'ancien `var` : **`let` respecte les blocs de code** ! 

**Qu'est-ce qu'un bloc ?** C'est tout ce qui est entre des accolades `{}` : les if, les boucles, ou m√™me des accolades seules.

**Pourquoi c'est important ?** Imaginez que vous ayez plusieurs pi√®ces dans une maison. Avec `let`, chaque variable reste dans sa pi√®ce. Avec `var`, les variables se prom√®nent partout dans la maison, ce qui cr√©e du d√©sordre !

**R√®gle simple :** Une variable `let` cr√©√©e dans un bloc (entre `{}`) n'existe QUE dans ce bloc. D√®s qu'on sort du bloc, elle dispara√Æt.

Voici comment √ßa fonctionne en pratique :

```javascript
function demonstrationPortee() {
    console.log("=== Variables let et les blocs ===");
    
    // 1. Variable de fonction - accessible partout dans la fonction
    let fonctionVariable = "Je suis accessible dans toute la fonction";
    
    if (true) {
        // 2. Variable de bloc - accessible seulement ici
        let blocVariable = "Je suis prisonni√®re de ce bloc if";
        console.log(fonctionVariable); // ‚úÖ OK, la variable de fonction est visible
        console.log(blocVariable);     // ‚úÖ OK, on est dans le bon bloc
    }
    
    console.log(fonctionVariable); // ‚úÖ OK, toujours dans la fonction
    // console.log(blocVariable);  // ‚ùå ERREUR ! Elle a disparu !
    
    // 3. Chaque boucle a sa propre "bulle"
    for (let i = 0; i < 3; i++) {
        let messageSecret = `Message secret ${i}`;
        console.log(messageSecret);
    }
    
    // console.log(i);             // ‚ùå ERREUR ! i n'existe plus
    // console.log(messageSecret); // ‚ùå ERREUR ! messageSecret non plus
}

demonstrationPortee();

// 4. M√™me nom, blocs diff√©rents = variables diff√©rentes !
{
    let temperature = "Chaud dans ce bloc !";
    console.log(temperature);
}

{
    let temperature = "Froid dans cet autre bloc !"; // ‚úÖ OK, bloc diff√©rent
    console.log(temperature);
}
```
{% endtab %}

{% tab title="R√©assignation vs red√©claration" %}
Avec `let`, il y a deux choses importantes √† comprendre : la diff√©rence entre **changer la valeur** (r√©assignation) et **recr√©er la variable** (red√©claration).

**R√©assignation = Changer le contenu de la bo√Æte** ‚úÖ Autoris√©
C'est comme vider votre sac √† dos et y mettre autre chose. La bo√Æte reste la m√™me, mais le contenu change.

**Red√©claration = Cr√©er une nouvelle bo√Æte du m√™me nom** ‚ùå Interdit dans le m√™me endroit
C'est comme avoir deux sacs √† dos avec exactement la m√™me √©tiquette dans la m√™me chambre. JavaScript ne sait plus lequel choisir !

**Mais attention :** Vous pouvez avoir le m√™me nom dans des endroits diff√©rents (comme avoir un sac "√©cole" dans votre chambre ET un sac "√©cole" dans le salon).

Voici comment √ßa marche :

```javascript
// ‚úÖ R√âASSIGNATION : Changer le contenu - Autoris√©
let score = 0;
console.log(score); // 0

score = 10;         // Je change le contenu
console.log(score); // 10

score = score + 5;  // Je calcule et je change
console.log(score); // 15

score += 10;        // Raccourci pour ajouter
console.log(score); // 25

// ‚ùå RED√âCLARATION : M√™me nom, m√™me endroit - Interdit
let joueur = "Alice";
// let joueur = "Bob"; // ‚ö†Ô∏è ERREUR ! Ce nom est d√©j√† pris ici

// ‚úÖ Mais dans des fonctions diff√©rentes, c'est OK
function equipe1() {
    let capitaine = "Sarah"; // OK, on est dans equipe1
    console.log(capitaine);
}

function equipe2() {
    let capitaine = "Lucas"; // ‚úÖ OK, on est dans equipe2 maintenant
    console.log(capitaine);
}

equipe1(); // "Sarah"
equipe2(); // "Lucas"

// ‚úÖ Dans des blocs s√©par√©s aussi, c'est OK
{
    let animal = "Chat";
    console.log(animal);
}

{
    let animal = "Chien"; // ‚úÖ OK, nouveau bloc, nouvel animal !
    console.log(animal);
}
```
{% endtab %}
{% endtabs %}

## ‚ö†Ô∏è var : L'ancienne m√©thode (√† √©viter)

### üìã Pourquoi √©viter var ?

{% hint style="warning" %}
**`var` pose plusieurs probl√®mes :** port√©e de fonction, hoisting d√©routant, red√©claration autoris√©e. Bien comprendre ses d√©fauts aide √† √©viter les bugs.
{% endhint %}

{% tabs %}
{% tab title="Probl√®mes de port√©e" %}
`var` √©tait l'ancienne fa√ßon de cr√©er des variables en JavaScript. Mais il a des comportements bizarres qui peuvent cr√©er des bugs difficiles √† comprendre ! Voici pourquoi vous devez l'√©viter :

**Probl√®me #1 : Les variables "fuient" des blocs**
Avec `var`, les variables ne restent pas dans leur bloc (entre `{}`). Elles se prom√®nent partout dans la fonction ! C'est comme si toutes vos affaires sortaient de votre chambre pour envahir toute la maison.

**Probl√®me #2 : Les boucles dysfonctionnent**
Dans les boucles avec `var`, toutes les variables partagent la m√™me "bo√Æte", ce qui cr√©e des r√©sultats inattendus.

**Probl√®me #3 : Pollution de l'environnement global**
Les variables `var` globales se collent √† l'objet `window` du navigateur, ce qui peut casser d'autres scripts.

Regardons ces probl√®mes en action :

```javascript
// ‚ö†Ô∏è PROBL√àME #1 : Les variables fuient des blocs

function problemeVar() {
    console.log("=== Les probl√®mes de var ===");
    
    if (true) {
        var varVariable = "Je m'√©chappe du bloc !";
        let letVariable = "Moi je reste bien sage dans mon bloc";
    }
    
    console.log(varVariable); // ‚úÖ "Je m'√©chappe du bloc !" - PROBL√âMATIQUE !
    // console.log(letVariable); // ‚ùå ERREUR - C'est normal et bien !
}

// ‚ö†Ô∏è PROBL√àME #2 : Boucles cass√©es avec var
console.log("=== Boucle avec var (ne marche pas) ===");
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log("var i:", i); // Affiche 3, 3, 3 (pas 0, 1, 2 !)
    }, 100);
}

console.log("=== Boucle avec let (marche bien) ===");
for (let j = 0; j < 3; j++) {
    setTimeout(() => {
        console.log("let j:", j); // Affiche 0, 1, 2 (correct !)
    }, 200);
}

// ‚ö†Ô∏è PROBL√àME #3 : Pollution globale
var variableSale = "Je pollue l'environnement global";
console.log(window.variableSale); // "Je pollue..." (dans le navigateur)

let variablePropre = "Moi je reste propre";
console.log(window.variablePropre); // undefined (bien !)
```
{% endtab %}

{% tab title="Hoisting d√©routant" %}
Le "hoisting" est un comportement √©trange de JavaScript avec `var`. En gros, JavaScript fait semblant de "remonter" toutes les variables `var` au d√©but de la fonction, mais sans leur valeur ! C'est comme si vous disiez "J'ai une bo√Æte quelque part" avant m√™me de l'avoir fabriqu√©e.

**Ce qui se passe dans votre t√™te :**
Vous √©crivez le code de haut en bas, pensant que les variables n'existent que quand vous les d√©clarez.

**Ce qui se passe r√©ellement :**
JavaScript "remonte" secr√®tement toutes les d√©clarations `var` au d√©but, mais les valeurs restent o√π vous les avez mises. R√©sultat : vous pouvez utiliser une variable avant de lui donner une valeur !

**Avec `let` et `const` :**
Pas de hoisting bizarre ! Si vous utilisez une variable avant de la d√©clarer, JavaScript vous dit clairement "Cette variable n'existe pas encore". C'est beaucoup plus clair !

```javascript
// ‚ö†Ô∏è COMPORTEMENT BIZARRE AVEC var

console.log("=== Le hoisting bizarre de var ===");

function testHoisting() {
    console.log("Valeur de maVariable:", maVariable); // undefined (pas d'erreur !)
    
    // ... du code ...
    
    var maVariable = "Je suis l√† !";
    
    console.log("Valeur apr√®s affectation:", maVariable); // "Je suis l√† !"
}

// Ce que JavaScript fait R√âELLEMENT dans les coulisses :
function ceQueJavaScriptVoit() {
    var maVariable; // D√©claration "remont√©e" au d√©but
    
    console.log("Valeur de maVariable:", maVariable); // undefined
    
    // ... du code ...
    
    maVariable = "Je suis l√† !"; // Seule l'affectation reste ici
    
    console.log("Valeur apr√®s affectation:", maVariable);
}

// ‚úÖ COMPORTEMENT NORMAL AVEC let/const

function testSansHoisting() {
    // console.log(maVariableLet); // ‚ùå ERREUR - C'est clair !
    
    let maVariableLet = "Je suis d√©clar√©e proprement";
    console.log("Valeur normale:", maVariableLet);
}

console.log("=== Test avec var ===");
testHoisting();

console.log("=== Test avec let ===");
testSansHoisting();
```
{% endtab %}

{% tab title="Red√©claration probl√©matique" %}
Avec `var`, JavaScript vous laisse cr√©er plusieurs variables avec le m√™me nom ! C'est comme avoir plusieurs bo√Ætes avec la m√™me √©tiquette dans votre chambre - vous ne savez plus laquelle utiliser. Et souvent, c'est accidentel et √ßa cr√©e des bugs !

**Le probl√®me :**
Quand vous √©crivez du code long, vous pouvez oublier qu'une variable existe d√©j√†. Avec `var`, JavaScript ne vous avertit pas - il √©crase silencieusement l'ancienne valeur !

**La solution avec let/const :**
Si vous essayez de cr√©er deux variables avec le m√™me nom, JavaScript vous dit imm√©diatement "Stop ! Ce nom est d√©j√† pris !" C'est comme un gardien qui v√©rifie qu'il n'y a pas de doublons.

**Pourquoi c'est important :**
Dans un vrai projet, vous pouvez avoir des milliers de lignes de code. Sans protection contre les noms en double, vous risquez d'√©craser des variables importantes par accident !

```javascript
// ‚ö†Ô∏è PROBL√àME : var autorise la red√©claration

console.log("=== Red√©claration avec var (dangereux) ===");

var utilisateur = "Alice";
console.log("Premier utilisateur:", utilisateur); // "Alice"

// Plus loin dans le code... (accidentellement)
var utilisateur = "Bob"; // ‚ö†Ô∏è Aucune erreur, mais c'√©tait peut-√™tre involontaire !
console.log("Utilisateur √©cras√©:", utilisateur); // "Bob" - Alice a disparu !

// ‚úÖ SOLUTION : let/const emp√™chent les red√©clarations

console.log("=== Protection avec let/const ===");

let produit = "Ordinateur";
console.log("Produit original:", produit);

// Cette ligne provoquerait une erreur imm√©diate :
// let produit = "Tablette"; // ‚ùå SyntaxError: Identifier 'produit' has already been declared

// Pour changer la valeur, on fait simplement :
produit = "Tablette neuve"; // ‚úÖ Modification autoris√©e
console.log("Produit modifi√©:", produit);

// Avec const, m√™me la modification est interdite :
const marque = "Apple";
// marque = "Samsung"; // ‚ùå TypeError: Assignment to constant variable
console.log("Marque prot√©g√©e:", marque);
```
{% endtab %}
{% endtabs %}

## üìè Port√©e (Scope) expliqu√©e

### üéØ Les diff√©rents types de port√©e

{% tabs %}
{% tab title="Port√©e globale" %}
La port√©e globale, c'est comme la salle commune de votre maison : tout le monde peut y acc√©der ! Les variables globales sont cr√©√©es en dehors de toute fonction ou bloc, et elles sont visibles partout dans votre programme.

**Avantages :**
- Accessibles depuis n'importe quelle fonction
- Pratiques pour des valeurs utilis√©es partout (comme le nom du site, la langue, etc.)

**Inconv√©nients :**
- Risque de conflits entre diff√©rentes parties du code
- Plus difficile de d√©boguer quand il y a des probl√®mes
- Peuvent √™tre modifi√©es n'importe o√π (risqu√© !)

**Conseil important :**
Utilisez les variables globales avec parcimonie ! C'est comme la t√©l√© dans le salon - si tout le monde peut la changer, √ßa peut cr√©er des disputes ! üòÑ

```javascript
// üåç VARIABLES GLOBALES (accessibles partout)

const SITE_NAME = "Mon Super Site"; // Constante globale (recommand√©)
let utilisateurConnecte = null;      // Variable globale (√† utiliser avec prudence)

function afficherSite() {
    console.log(`Bienvenue sur ${SITE_NAME}`); // ‚úÖ Accessible partout
}

function connecterUtilisateur(nom) {
    utilisateurConnecte = nom; // ‚úÖ Modification possible depuis n'importe o√π
    console.log(`${nom} est maintenant connect√©`);
}

function obtenirUtilisateur() {
    return utilisateurConnecte; // ‚úÖ Lecture possible depuis n'importe o√π
}

function deconnecterUtilisateur() {
    utilisateurConnecte = null; // ‚úÖ Remise √† z√©ro possible
    console.log("Utilisateur d√©connect√©");
}

// Test des fonctions
console.log("=== Test des variables globales ===");
afficherSite();                        // "Bienvenue sur Mon Super Site"
connecterUtilisateur("Alice");         // "Alice est maintenant connect√©"
console.log("Utilisateur actuel:", obtenirUtilisateur()); // "Alice"
deconnecterUtilisateur();              // "Utilisateur d√©connect√©"
console.log("Utilisateur apr√®s d√©connexion:", obtenirUtilisateur()); // null

// ‚ö†Ô∏è Probl√®me potentiel : modification accidentelle
function fonctionMalicieuse() {
    utilisateurConnecte = "Hacker"; // Oops ! Modification non d√©sir√©e
}

console.log("=== Avant la fonction malicieuse ===");
connecterUtilisateur("Bob");
console.log("Utilisateur:", obtenirUtilisateur()); // "Bob"

console.log("=== Apr√®s la fonction malicieuse ===");
fonctionMalicieuse();
console.log("Utilisateur:", obtenirUtilisateur()); // "Hacker" - Probl√®me !
```
{% endtab %}

{% tab title="Port√©e de fonction" %}
```javascript
// üè† Port√©e de fonction : accessible dans toute la fonction

function calculatrice() {
    // Variables de fonction
    const nom = "Calculatrice Pro";
    let historique = [];
    
    function additionner(a, b) {
        const resultat = a + b;
        // Ces variables sont accessibles car dans la m√™me fonction
        historique.push(`${a} + ${b} = ${resultat}`);
        return resultat;
    }
    
    function multiplier(a, b) {
        const resultat = a * b;
        // Acc√®s aux variables de la fonction parent
        historique.push(`${a} √ó ${b} = ${resultat}`);
        return resultat;
    }
    
    function afficherHistorique() {
        console.log(`=== ${nom} ===`);
        historique.forEach(operation => console.log(operation));
    }
    
    // Interface publique
    return {
        additionner,
        multiplier,
        afficherHistorique
    };
}

// Test
const calc = calculatrice();
calc.additionner(5, 3);    // 8
calc.multiplier(4, 7);     // 28
calc.afficherHistorique(); 

// ‚ùå Variables internes inaccessibles depuis l'ext√©rieur
// console.log(nom);       // ReferenceError
// console.log(historique); // ReferenceError
```
{% endtab %}

{% tab title="Port√©e de bloc" %}
```javascript
// üì¶ Port√©e de bloc : accessible seulement dans le bloc {}

function demonstrationBlocs() {
    const niveau = "fonction";
    
    // Bloc if
    if (true) {
        const niveau = "bloc if";        // Masque la variable de fonction
        let messageIf = "Je suis dans le if";
        console.log(`Dans if: ${niveau}`);     // "bloc if"
        console.log(messageIf);                 // "Je suis dans le if"
    }
    
    // Bloc else
    if (false) {
        // Ce bloc ne s'ex√©cute pas
    } else {
        const niveau = "bloc else";      // Nouvelle variable, m√™me nom
        let messageElse = "Je suis dans le else";
        console.log(`Dans else: ${niveau}`);   // "bloc else"
        console.log(messageElse);               // "Je suis dans le else"
    }
    
    // Bloc for
    for (let i = 0; i < 2; i++) {
        const niveau = "bloc for";       // Encore une nouvelle variable
        let messageBoucle = `It√©ration ${i}`;
        console.log(`Dans boucle: ${niveau}`); // "bloc for"
        console.log(messageBoucle);             // "It√©ration X"
    }
    
    // Bloc arbitraire
    {
        const niveau = "bloc arbitraire";
        let messageBloc = "Je suis dans un bloc simple";
        console.log(`Dans bloc: ${niveau}`);   // "bloc arbitraire"
        console.log(messageBloc);               // "Je suis dans un bloc simple"
    }
    
    // Retour au niveau fonction
    console.log(`Niveau fonction: ${niveau}`); // "fonction"
    
    // ‚ùå Ces variables ne sont plus accessibles
    // console.log(messageIf);      // ReferenceError
    // console.log(messageElse);    // ReferenceError
    // console.log(messageBoucle);  // ReferenceError
    // console.log(messageBloc);    // ReferenceError
}

demonstrationBlocs();
```
{% endtab %}
{% endtabs %}

## üß™ Exercices pratiques

### üéØ Exercice 1 : Gestionnaire de score

{% hint style="info" %}
**Objectif :** Cr√©er un syst√®me de gestion de score avec les bonnes d√©clarations
{% endhint %}

```javascript
// Cr√©ez un gestionnaire de score qui :
// - Stocke le score actuel
// - Permet d'ajouter des points
// - Garde un historique des modifications
// - Affiche un r√©sum√©

// Utilisez const, let appropri√©s et √©vitez var
```

<details>
<summary>üí° Solution</summary>

```javascript
// üéØ Gestionnaire de score avec bonnes pratiques

function creerGestionnaireScore() {
    // Configuration constante
    const CONFIG = {
        scoreInitial: 0,
        scoreMaximum: 1000,
        bonusMultiplicateur: 1.5
    };
    
    // √âtat modifiable
    let scoreActuel = CONFIG.scoreInitial;
    let nombreActions = 0;
    
    // Historique (const car on ne r√©assigne jamais le tableau)
    const historique = [];
    
    function ajouterPoints(points, raison = "Points ajout√©s") {
        // Validation locale
        const pointsValides = Math.max(0, points);
        const ancienScore = scoreActuel;
        
        // Modification du score
        scoreActuel = Math.min(scoreActuel + pointsValides, CONFIG.scoreMaximum);
        nombreActions++;
        
        // Enregistrement dans l'historique
        historique.push({
            action: raison,
            points: pointsValides,
            ancienScore,
            nouveauScore: scoreActuel,
            timestamp: new Date().toLocaleTimeString()
        });
        
        console.log(`‚úÖ ${raison}: +${pointsValides} points (Score: ${scoreActuel})`);
        return scoreActuel;
    }
    
    function retirerPoints(points, raison = "Points retir√©s") {
        const pointsValides = Math.max(0, points);
        const ancienScore = scoreActuel;
        
        scoreActuel = Math.max(scoreActuel - pointsValides, 0);
        nombreActions++;
        
        historique.push({
            action: raison,
            points: -pointsValides,
            ancienScore,
            nouveauScore: scoreActuel,
            timestamp: new Date().toLocaleTimeString()
        });
        
        console.log(`‚ùå ${raison}: -${pointsValides} points (Score: ${scoreActuel})`);
        return scoreActuel;
    }
    
    function appliquerBonus() {
        const bonus = Math.floor(scoreActuel * (CONFIG.bonusMultiplicateur - 1));
        return ajouterPoints(bonus, "Bonus appliqu√©");
    }
    
    function obtenirResume() {
        return {
            scoreActuel,
            nombreActions,
            scoreMaximumAtteint: scoreActuel === CONFIG.scoreMaximum,
            historique: [...historique] // Copie pour √©viter les modifications
        };
    }
    
    function afficherHistorique() {
        console.log("\nüìä Historique des actions:");
        console.log("=" .repeat(50));
        
        if (historique.length === 0) {
            console.log("Aucune action effectu√©e");
            return;
        }
        
        historique.forEach((action, index) => {
            const signe = action.points >= 0 ? "+" : "";
            console.log(
                `${index + 1}. [${action.timestamp}] ${action.action}: ` +
                `${signe}${action.points} (${action.ancienScore} ‚Üí ${action.nouveauScore})`
            );
        });
        
        console.log("=" .repeat(50));
        console.log(`Score final: ${scoreActuel} | Actions: ${nombreActions}`);
    }
    
    function reinitialiser() {
        scoreActuel = CONFIG.scoreInitial;
        nombreActions = 0;
        historique.length = 0; // Vider le tableau sans le r√©assigner
        console.log("üîÑ Score r√©initialis√©");
    }
    
    // Interface publique
    return {
        ajouterPoints,
        retirerPoints,
        appliquerBonus,
        obtenirResume,
        afficherHistorique,
        reinitialiser,
        
        // Getters pour lecture seule
        get score() { return scoreActuel; },
        get actions() { return nombreActions; },
        get historique() { return [...historique]; }
    };
}

// üß™ Test du gestionnaire
console.log("üéÆ Test du Gestionnaire de Score");
console.log("=" .repeat(40));

const jeu = creerGestionnaireScore();

// Sc√©nario de jeu
jeu.ajouterPoints(50, "Ennemi vaincu");
jeu.ajouterPoints(100, "Niveau termin√©");
jeu.retirerPoints(25, "D√©g√¢ts subis");
jeu.ajouterPoints(200, "Boss vaincu");
jeu.appliquerBonus();
jeu.retirerPoints(50, "Pi√®ge activ√©");

// Affichage des r√©sultats
jeu.afficherHistorique();

const resume = jeu.obtenirResume();
console.log("\nüìà R√©sum√© final:", resume);

// Test de l'interface en lecture seule
console.log(`\nScore actuel: ${jeu.score}`);
console.log(`Nombre d'actions: ${jeu.actions}`);
```

</details>

### üéØ Exercice 2 : Configuration d'application

{% hint style="info" %}
**Objectif :** Cr√©er un syst√®me de configuration avec validation
{% endhint %}

```javascript
// Cr√©ez un syst√®me qui :
// - G√®re des param√®tres d'application
// - Valide les modifications
// - Garde les valeurs par d√©faut
// - Permet la r√©initialisation

// Utilisez const pour les valeurs fixes, let pour les modifiables
```

<details>
<summary>üí° Solution</summary>

```javascript
// üîß Syst√®me de configuration d'application

function creerGestionnaireConfig() {
    // Valeurs par d√©faut (constantes)
    const DEFAULTS = {
        theme: "clair",
        langue: "fr",
        notifications: true,
        volumeSon: 50,
        qualiteGraphique: "moyenne",
        sauvegardeAuto: true,
        timeoutSession: 30
    };
    
    // Validation rules (constantes)
    const VALIDATION = {
        theme: ["clair", "sombre", "automatique"],
        langue: ["fr", "en", "es", "de"],
        volumeSon: { min: 0, max: 100 },
        qualiteGraphique: ["basse", "moyenne", "haute", "ultra"],
        timeoutSession: { min: 5, max: 120 }
    };
    
    // Configuration actuelle (modifiable)
    let configActuelle = { ...DEFAULTS };
    let modificationsNonSauvees = false;
    
    // Historique des modifications
    const historiqueModifications = [];
    
    function validerValeur(cle, valeur) {
        const regle = VALIDATION[cle];
        
        if (!regle) {
            return true; // Pas de validation sp√©cifique
        }
        
        if (Array.isArray(regle)) {
            return regle.includes(valeur);
        }
        
        if (typeof regle === "object" && regle.min !== undefined) {
            return valeur >= regle.min && valeur <= regle.max;
        }
        
        return true;
    }
    
    function modifier(cle, nouvelleValeur) {
        if (!(cle in DEFAULTS)) {
            console.error(`‚ùå Cl√© de configuration inconnue: ${cle}`);
            return false;
        }
        
        if (!validerValeur(cle, nouvelleValeur)) {
            const regle = VALIDATION[cle];
            let messageErreur = `‚ùå Valeur invalide pour ${cle}: ${nouvelleValeur}`;
            
            if (Array.isArray(regle)) {
                messageErreur += `. Valeurs autoris√©es: ${regle.join(", ")}`;
            } else if (typeof regle === "object") {
                messageErreur += `. Plage autoris√©e: ${regle.min}-${regle.max}`;
            }
            
            console.error(messageErreur);
            return false;
        }
        
        const ancienneValeur = configActuelle[cle];
        
        if (ancienneValeur !== nouvelleValeur) {
            configActuelle[cle] = nouvelleValeur;
            modificationsNonSauvees = true;
            
            historiqueModifications.push({
                cle,
                ancienneValeur,
                nouvelleValeur,
                timestamp: new Date().toISOString()
            });
            
            console.log(`‚úÖ ${cle}: ${ancienneValeur} ‚Üí ${nouvelleValeur}`);
        }
        
        return true;
    }
    
    function obtenirValeur(cle) {
        if (cle) {
            return configActuelle[cle];
        }
        return { ...configActuelle }; // Copie pour √©viter les modifications
    }
    
    function reinitialiser(cles = null) {
        const clesPourReinit = cles || Object.keys(DEFAULTS);
        let nombreReinit = 0;
        
        for (const cle of clesPourReinit) {
            if (cle in configActuelle) {
                const ancienneValeur = configActuelle[cle];
                const valeurDefaut = DEFAULTS[cle];
                
                if (ancienneValeur !== valeurDefaut) {
                    configActuelle[cle] = valeurDefaut;
                    nombreReinit++;
                    
                    historiqueModifications.push({
                        cle,
                        ancienneValeur,
                        nouvelleValeur: valeurDefaut,
                        timestamp: new Date().toISOString(),
                        type: "reinitialisation"
                    });
                }
            }
        }
        
        if (nombreReinit > 0) {
            modificationsNonSauvees = true;
            console.log(`üîÑ ${nombreReinit} param√®tre(s) r√©initialis√©(s)`);
        } else {
            console.log("‚ÑπÔ∏è Aucune modification n√©cessaire");
        }
    }
    
    function sauvegarder() {
        // Simulation de sauvegarde
        const configPourSauvegarde = JSON.stringify(configActuelle, null, 2);
        console.log("üíæ Configuration sauvegard√©e:");
        console.log(configPourSauvegarde);
        
        modificationsNonSauvees = false;
        return true;
    }
    
    function afficherConfig() {
        console.log("\n‚öôÔ∏è Configuration actuelle:");
        console.log("=" .repeat(40));
        
        Object.entries(configActuelle).forEach(([cle, valeur]) => {
            const estDefaut = valeur === DEFAULTS[cle];
            const indicateur = estDefaut ? "üìò" : "üìô";
            console.log(`${indicateur} ${cle}: ${valeur}`);
        });
        
        if (modificationsNonSauvees) {
            console.log("\n‚ö†Ô∏è Modifications non sauvegard√©es");
        }
        
        console.log("=" .repeat(40));
    }
    
    function afficherHistorique() {
        console.log("\nüìú Historique des modifications:");
        console.log("=" .repeat(50));
        
        if (historiqueModifications.length === 0) {
            console.log("Aucune modification effectu√©e");
            return;
        }
        
        historiqueModifications.forEach((modif, index) => {
            const date = new Date(modif.timestamp).toLocaleString();
            const type = modif.type ? ` [${modif.type}]` : "";
            console.log(
                `${index + 1}. [${date}] ${modif.cle}${type}: ` +
                `${modif.ancienneValeur} ‚Üí ${modif.nouvelleValeur}`
            );
        });
    }
    
    function exporterConfig() {
        return {
            configuration: { ...configActuelle },
            estSauvegarde: !modificationsNonSauvees,
            valeursParDefaut: { ...DEFAULTS },
            nombreModifications: historiqueModifications.length
        };
    }
    
    // Interface publique
    return {
        modifier,
        obtenirValeur,
        reinitialiser,
        sauvegarder,
        afficherConfig,
        afficherHistorique,
        exporterConfig,
        
        // Getters pour lecture seule
        get modifiee() { return modificationsNonSauvees; },
        get defaults() { return { ...DEFAULTS }; }
    };
}

// üß™ Test du gestionnaire de configuration
console.log("‚öôÔ∏è Test du Gestionnaire de Configuration");
console.log("=" .repeat(45));

const config = creerGestionnaireConfig();

// Configuration initiale
config.afficherConfig();

// Tests de modification
console.log("\nüîß Tests de modification:");
config.modifier("theme", "sombre");
config.modifier("volumeSon", 75);
config.modifier("langue", "en");

// Test de validation
config.modifier("volumeSon", 150); // Erreur attendue
config.modifier("theme", "inexistant"); // Erreur attendue

// Affichage apr√®s modifications
config.afficherConfig();

// Test de r√©initialisation partielle
console.log("\nüîÑ R√©initialisation du th√®me:");
config.reinitialiser(["theme"]);

// Affichage de l'historique
config.afficherHistorique();

// Export final
console.log("\nüì§ Export de la configuration:");
const exportData = config.exporterConfig();
console.log(JSON.stringify(exportData, null, 2));
```

</details>

## üéØ Quiz de validation

{% hint style="info" %}
**Question 1 :** Quelle est la diff√©rence principale entre `let` et `const` ?
{% endhint %}

<details>
<summary>üí° R√©ponse</summary>

**Diff√©rence principale : la r√©assignation**

- **`let`** : Variable **r√©assignable** apr√®s d√©claration
- **`const`** : Variable **non r√©assignable** apr√®s d√©claration

```javascript
let age = 25;
age = 26; // ‚úÖ OK

const nom = "Alice";
nom = "Bob"; // ‚ùå TypeError: Assignment to constant variable
```

**Important :** `const` emp√™che la r√©assignation, mais pas la mutation des objets !

</details>

{% hint style="info" %}
**Question 2 :** Pourquoi √©viter `var` en JavaScript moderne ?
{% endhint %}

<details>
<summary>üí° R√©ponse</summary>

**Probl√®mes de `var` :**

1. **Port√©e de fonction** au lieu de bloc ‚Üí fuite de variables
2. **Hoisting d√©routant** ‚Üí variables utilisables avant d√©claration  
3. **Red√©claration autoris√©e** ‚Üí erreurs silencieuses
4. **Pollution globale** ‚Üí variables ajout√©es √† `window`

**Solution :** Utiliser `const` par d√©faut, `let` si r√©assignation n√©cessaire.

</details>

## üîó Liens avec d'autres concepts

{% content-ref url="types-donnees.md" %}
[types-donnees.md](types-donnees.md)
{% endcontent-ref %}

{% content-ref url="hoisting-portee.md" %}
[hoisting-portee.md](hoisting-portee.md)
{% endcontent-ref %}

{% content-ref url="../niveau-intermediaire/closures-lexical-scope.md" %}
[closures-lexical-scope.md](../niveau-intermediaire/closures-lexical-scope.md)
{% endcontent-ref %}

## üöÄ Prochaines √©tapes

{% hint style="success" %}
**Maintenant que vous ma√Ætrisez les d√©clarations :**

üëâ **Explorez** les [Types de Donn√©es](types-donnees.md)  
üëâ **Approfondissez** le [Hoisting et la Port√©e](hoisting-portee.md)  
üëâ **D√©couvrez** les [Structures de Contr√¥le](structures-controle.md)  
{% endhint %}

## üéØ R√©sum√©

{% hint style="info" %}
**Points cl√©s √† retenir :**

ü•á **`const` par d√©faut** : Pour toutes les valeurs non r√©assign√©es  
ü•à **`let` si n√©cessaire** : Quand r√©assignation requise  
üö´ **√âviter `var`** : Probl√®mes de port√©e et hoisting  
üì¶ **Port√©e de bloc** : `let` et `const` respectent les blocs {}  
üõ°Ô∏è **Validation** : Erreurs imm√©diates avec `let`/`const`  
{% endhint %}

---

{% hint style="warning" %}
**Pr√™t pour la suite ?** D√©couvrons maintenant les [Types de Donn√©es](types-donnees.md) !
{% endhint %}
