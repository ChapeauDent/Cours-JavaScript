# üîê Closures et Lexical Scope

{% hint style="info" %}
**Niveau :** üü° Interm√©diaire | **Dur√©e :** 45 min | **Pr√©requis :** Fonctions, Hoisting, Port√©e
{% endhint %}

## üéØ Objectifs d'apprentissage

{% hint style="success" %}
√Ä la fin de cette le√ßon, vous serez capable de :
- [ ] **Comprendre** le m√©canisme des closures et du lexical scope
- [ ] **Cr√©er** des fonctions avec donn√©es priv√©es
- [ ] **Appliquer** les patterns courants avec closures
- [ ] **D√©boguer** les probl√®mes li√©s aux closures
{% endhint %}

## üîë Concepts cl√©s

{% tabs %}
{% tab title="D√©finitions" %}
**Closure** : Fonction qui "capture" des variables de son environnement  
**Lexical Scope** : Port√©e d√©termin√©e par o√π les variables sont d√©clar√©es  
**Factory Function** : Fonction qui cr√©e d'autres fonctions avec closures  
**Encapsulation** : Protection des donn√©es internes  
{% endtab %}

{% tab title="Importance" %}
üèóÔ∏è **Encapsulation** : Cr√©er des donn√©es priv√©es  
üè≠ **Factory patterns** : G√©n√©rer des fonctions sp√©cialis√©es  
‚ö° **Callbacks avanc√©s** : Pr√©server le contexte  
üì¶ **Modules** : Organiser le code proprement  
{% endtab %}
{% endtabs %}

## üìñ Lexical Scope expliqu√©

{% hint style="warning" %}
**Lexical Scope :** La port√©e est d√©termin√©e par **o√π** les variables sont d√©clar√©es dans le code, pas par **comment** les fonctions sont appel√©es.
{% endhint %}

### üîç Visualisation de la cha√Æne de port√©es

{% tabs %}
{% tab title="Exemple de base" %}
```javascript
let global = "Je suis globale";

function externe() {
  let secret = "Je suis dans externe()";
  
  function interne() {
    let local = "Je suis locale";
    
    // interne() a acc√®s √† TOUTES ces variables :
    console.log(local);  // ‚úÖ Variable locale
    console.log(secret); // ‚úÖ Variable du parent
    console.log(global); // ‚úÖ Variable globale
  }
  
  return interne;
}

const maFonction = externe();
maFonction(); // Fonctionne m√™me apr√®s la fin d'externe() !
```
{% endtab %}

{% tab title="Cha√Æne de recherche" %}
```javascript
// JavaScript cherche les variables dans cet ordre :
// 1. Scope local (interne)
// 2. Scope parent (externe) 
// 3. Scope global
// 4. ReferenceError si introuvable

function a() {
  let x = 1;
  
  function b() {
    let x = 2; // Masque le x du parent
    
    function c() {
      console.log(x); // Affiche 2 (le plus proche)
    }
    
    return c;
  }
  
  return b;
}
```
{% endtab %}
{% endtabs %}

## üèóÔ∏è Qu'est-ce qu'une Closure ?

### üìã D√©finition simple

{% hint style="info" %}
**Une closure = fonction + environnement lexical dans lequel elle a √©t√© cr√©√©e**

La fonction "se souvient" des variables de son environnement, m√™me apr√®s que cet environnement ait disparu !
{% endhint %}

### üéØ Exemple fondamental

{% tabs %}
{% tab title="Compteur avec closure" %}
```javascript
function creerCompteur() {
  let compteur = 0; // Variable "captur√©e"
  
  return function() {
    compteur++; // La fonction "se souvient" de compteur
    return compteur;
  };
}

const monCompteur = creerCompteur();
console.log(monCompteur()); // 1
console.log(monCompteur()); // 2
console.log(monCompteur()); // 3

// La variable 'compteur' est toujours accessible !
// Elle vit dans la closure
```
{% endtab %}

{% tab title="Plusieurs instances" %}
```javascript
function creerCompteur() {
  let compteur = 0;
  
  return function() {
    compteur++;
    return compteur;
  };
}

// Chaque compteur a sa propre closure !
const compteur1 = creerCompteur();
const compteur2 = creerCompteur();

console.log(compteur1()); // 1
console.log(compteur1()); // 2
console.log(compteur2()); // 1 (ind√©pendant !)
console.log(compteur1()); // 3
```
{% endtab %}
{% endtabs %}

## üè≠ Factory Functions et Donn√©es Priv√©es

### üîí Encapsulation avec closures

{% tabs %}
{% tab title="Compte bancaire s√©curis√©" %}
```javascript
function creerCompteBancaire(soldeInitial) {
  let solde = soldeInitial; // Variable priv√©e !
  
  return {
    // M√©thodes publiques
    deposer(montant) {
      if (montant > 0) {
        solde += montant;
        return `D√©p√¥t de ${montant}‚Ç¨. Solde: ${solde}‚Ç¨`;
      }
      return "Montant invalide";
    },
    
    retirer(montant) {
      if (montant > 0 && montant <= solde) {
        solde -= montant;
        return `Retrait de ${montant}‚Ç¨. Solde: ${solde}‚Ç¨`;
      }
      return "Retrait impossible";
    },
    
    consulterSolde() {
      return `Solde actuel: ${solde}‚Ç¨`;
    }
    
    // Pas d'acc√®s direct √† 'solde' depuis l'ext√©rieur !
  };
}

const compte = creerCompteBancaire(100);
console.log(compte.consulterSolde()); // "Solde actuel: 100‚Ç¨"
console.log(compte.deposer(50));      // "D√©p√¥t de 50‚Ç¨. Solde: 150‚Ç¨"
console.log(compte.retirer(30));      // "Retrait de 30‚Ç¨. Solde: 120‚Ç¨"

// ‚ùå Impossible d'acc√©der directement au solde
console.log(compte.solde); // undefined
```
{% endtab %}

{% tab title="Configuration d'API" %}
```javascript
function creerApiClient(baseUrl, apiKey) {
  // Donn√©es priv√©es dans la closure
  const config = {
    baseUrl,
    apiKey,
    timeout: 5000
  };
  
  return {
    get(endpoint) {
      return fetch(`${config.baseUrl}${endpoint}`, {
        headers: {
          'Authorization': `Bearer ${config.apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: config.timeout
      });
    },
    
    post(endpoint, data) {
      return fetch(`${config.baseUrl}${endpoint}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${config.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data),
        timeout: config.timeout
      });
    },
    
    // Configuration prot√©g√©e
    setTimeout(newTimeout) {
      config.timeout = newTimeout;
    }
  };
}

const api = creerApiClient('https://api.example.com', 'secret-key');
api.get('/users').then(response => response.json());
```
{% endtab %}
{% endtabs %}

## üéÆ Patterns courants avec closures

### 1. üéõÔ∏è Module Pattern

{% tabs %}
{% tab title="Module simple" %}
```javascript
const MonModule = (function() {
  // Variables priv√©es
  let compteurPriv√© = 0;
  const donn√©esPriv√©es = [];
  
  // Fonctions priv√©es
  function fonctionPriv√©e() {
    return "Accessible seulement dans le module";
  }
  
  // API publique
  return {
    incrementer() {
      compteurPriv√©++;
      return compteurPriv√©;
    },
    
    ajouter(item) {
      donn√©esPriv√©es.push(item);
      return donn√©esPriv√©es.length;
    },
    
    obtenirTotal() {
      return compteurPriv√©;
    },
    
    obtenirDonn√©es() {
      return [...donn√©esPriv√©es]; // Copie pour protection
    }
  };
})();

// Utilisation
console.log(MonModule.incrementer()); // 1
console.log(MonModule.ajouter("test")); // 1
console.log(MonModule.obtenirTotal()); // 1

// ‚ùå Acc√®s impossible aux donn√©es priv√©es
console.log(MonModule.compteurPriv√©); // undefined
```
{% endtab %}

{% tab title="Module avec param√®tres" %}
```javascript
const creerCalculatrice = (function() {
  return function(nom) {
    let historique = [];
    
    return {
      nom,
      
      additionner(a, b) {
        const r√©sultat = a + b;
        historique.push(`${a} + ${b} = ${r√©sultat}`);
        return r√©sultat;
      },
      
      multiplier(a, b) {
        const r√©sultat = a * b;
        historique.push(`${a} √ó ${b} = ${r√©sultat}`);
        return r√©sultat;
      },
      
      obtenirHistorique() {
        return [...historique];
      },
      
      effacerHistorique() {
        historique = [];
        return "Historique effac√©";
      }
    };
  };
})();

const calc1 = creerCalculatrice("Calculatrice Pro");
const calc2 = creerCalculatrice("Calculatrice Basic");

calc1.additionner(5, 3); // 8
calc2.multiplier(4, 7);  // 28

console.log(calc1.obtenirHistorique()); // ["5 + 3 = 8"]
console.log(calc2.obtenirHistorique()); // ["4 √ó 7 = 28"]
```
{% endtab %}
{% endtabs %}

### 2. üîÑ Callbacks et Event Handlers

{% tabs %}
{% tab title="Gestionnaire d'√©v√©nements" %}
```javascript
function creerGestionnaireClics(message) {
  let nombreClics = 0;
  
  return function(event) {
    nombreClics++;
    console.log(`${message} - Clic n¬∞${nombreClics}`);
    
    // La closure "se souvient" de message et nombreClics
    if (nombreClics >= 5) {
      console.log("Limite de clics atteinte !");
      event.target.removeEventListener('click', arguments.callee);
    }
  };
}

// Utilisation avec des √©l√©ments DOM
const bouton1 = document.getElementById('btn1');
const bouton2 = document.getElementById('btn2');

bouton1.addEventListener('click', creerGestionnaireClics('Bouton 1 cliqu√©'));
bouton2.addEventListener('click', creerGestionnaireClics('Bouton 2 cliqu√©'));

// Chaque bouton a son propre compteur !
```
{% endtab %}

{% tab title="Timeout avec contexte" %}
```javascript
function creerProgrammateur(nom) {
  let t√¢ches = [];
  
  return {
    programmer(callback, d√©lai, ...args) {
      const id = Date.now();
      
      const timeoutId = setTimeout(() => {
        console.log(`[${nom}] Ex√©cution de la t√¢che ${id}`);
        callback(...args);
        
        // Supprimer de la liste des t√¢ches
        t√¢ches = t√¢ches.filter(t => t.id !== id);
      }, d√©lai);
      
      t√¢ches.push({ id, timeoutId, d√©lai });
      return id;
    },
    
    annuler(id) {
      const t√¢che = t√¢ches.find(t => t.id === id);
      if (t√¢che) {
        clearTimeout(t√¢che.timeoutId);
        t√¢ches = t√¢ches.filter(t => t.id !== id);
        return `T√¢che ${id} annul√©e`;
      }
      return "T√¢che introuvable";
    },
    
    obtenirT√¢chesEnCours() {
      return t√¢ches.map(t => ({ id: t.id, d√©lai: t.d√©lai }));
    }
  };
}

const programmateur = creerProgrammateur("Mon Programmateur");

const id1 = programmateur.programmer(() => {
  console.log("T√¢che 1 ex√©cut√©e !");
}, 2000);

const id2 = programmateur.programmer((message) => {
  console.log(`T√¢che 2: ${message}`);
}, 1000, "Hello World!");

console.log(programmateur.obtenirT√¢chesEnCours());
```
{% endtab %}
{% endtabs %}

## üêõ Pi√®ges courants et solutions

### ‚ö†Ô∏è Pi√®ge classique : Boucles et closures

{% tabs %}
{% tab title="‚ùå Probl√®me" %}
```javascript
// ‚ùå Pi√®ge classique avec var
function creerFonctions() {
  const fonctions = [];
  
  for (var i = 0; i < 3; i++) {
    fonctions.push(function() {
      console.log(i); // Affiche toujours 3 !
    });
  }
  
  return fonctions;
}

const mesFonctions = creerFonctions();
mesFonctions[0](); // 3 (pas 0 !)
mesFonctions[1](); // 3 (pas 1 !)
mesFonctions[2](); // 3 (pas 2 !)

// Probl√®me : toutes les fonctions partagent la m√™me variable i
```
{% endtab %}

{% tab title="‚úÖ Solutions" %}
```javascript
// ‚úÖ Solution 1 : let (scope de bloc)
function creerFonctions() {
  const fonctions = [];
  
  for (let i = 0; i < 3; i++) { // let au lieu de var
    fonctions.push(function() {
      console.log(i); // Chaque i est dans son propre scope
    });
  }
  
  return fonctions;
}

// ‚úÖ Solution 2 : IIFE (Immediately Invoked Function Expression)
function creerFonctions() {
  const fonctions = [];
  
  for (var i = 0; i < 3; i++) {
    fonctions.push((function(index) {
      return function() {
        console.log(index); // Capture index dans la closure
      };
    })(i));
  }
  
  return fonctions;
}

// ‚úÖ Solution 3 : bind()
function creerFonctions() {
  const fonctions = [];
  
  for (var i = 0; i < 3; i++) {
    fonctions.push(function(index) {
      console.log(index);
    }.bind(null, i));
  }
  
  return fonctions;
}
```
{% endtab %}
{% endtabs %}

### üß† Fuites m√©moire et performance

{% hint style="warning" %}
**Attention :** Les closures gardent des r√©f√©rences vers leur environnement lexical, ce qui peut causer des fuites m√©moire !
{% endhint %}

{% tabs %}
{% tab title="‚ö†Ô∏è Probl√®me de m√©moire" %}
```javascript
// ‚ùå Fuite m√©moire potentielle
function creerGestionnaireAvecFuite() {
  const grosseseDonn√©es = new Array(1000000).fill('data'); // 1M d'√©l√©ments
  
  return function() {
    // Cette fonction garde toute grosseseDonn√©es en m√©moire
    // m√™me si elle n'utilise qu'un √©l√©ment !
    return grosseseDonn√©es[0];
  };
}

// grosseseDonn√©es ne sera jamais lib√©r√©e !
```
{% endtab %}

{% tab title="‚úÖ Solution optimis√©e" %}
```javascript
// ‚úÖ Optimisation
function creerGestionnaireOptimis√©() {
  const grosseseDonn√©es = new Array(1000000).fill('data');
  const premierElement = grosseseDonn√©es[0]; // Extraire seulement ce qui est n√©cessaire
  
  // Lib√©rer la r√©f√©rence
  grosseseDonn√©es = null;
  
  return function() {
    return premierElement; // Seul premierElement est gard√© en m√©moire
  };
}

// Ou mieux : ne capturer que ce qui est n√©cessaire
function creerGestionnaireMinimal() {
  const grosseseDonn√©es = new Array(1000000).fill('data');
  
  return (function(element) {
    // IIFE qui capture seulement l'√©l√©ment n√©cessaire
    return function() {
      return element;
    };
  })(grosseseDonn√©es[0]);
}
```
{% endtab %}
{% endtabs %}

## üß™ Exercices pratiques

### üéØ Exercice 1 : Cache avec TTL

{% hint style="info" %}
**Cr√©ez un syst√®me de cache avec expiration automatique :**
{% endhint %}

```javascript
// Cr√©ez une fonction creerCache() qui retourne un objet avec :
// - set(cl√©, valeur, ttl) : stocke une valeur avec time-to-live
// - get(cl√©) : r√©cup√®re une valeur si elle n'a pas expir√©
// - clear() : vide le cache
// - size() : retourne le nombre d'√©l√©ments

// Utilisation attendue :
const cache = creerCache();
cache.set('user:1', { nom: 'Alice' }, 5000); // Expire dans 5s
cache.set('user:2', { nom: 'Bob' }, 10000);  // Expire dans 10s

console.log(cache.get('user:1')); // { nom: 'Alice' }
// Apr√®s 6s :
console.log(cache.get('user:1')); // null (expir√©)
console.log(cache.size()); // 1 (user:2 encore valide)
```

<details>
<summary>üí° Solution</summary>

```javascript
function creerCache() {
  let cache = new Map();
  
  return {
    set(cl√©, valeur, ttl = Infinity) {
      const expiration = Date.now() + ttl;
      cache.set(cl√©, { valeur, expiration });
      
      // Nettoyage automatique apr√®s expiration
      if (ttl !== Infinity) {
        setTimeout(() => {
          if (cache.has(cl√©)) {
            const item = cache.get(cl√©);
            if (item && Date.now() >= item.expiration) {
              cache.delete(cl√©);
            }
          }
        }, ttl);
      }
    },
    
    get(cl√©) {
      if (!cache.has(cl√©)) return null;
      
      const item = cache.get(cl√©);
      if (Date.now() >= item.expiration) {
        cache.delete(cl√©);
        return null;
      }
      
      return item.valeur;
    },
    
    clear() {
      cache.clear();
    },
    
    size() {
      // Nettoyer les √©l√©ments expir√©s avant de compter
      const now = Date.now();
      for (const [cl√©, item] of cache.entries()) {
        if (now >= item.expiration) {
          cache.delete(cl√©);
        }
      }
      return cache.size;
    }
  };
}
```

</details>

### üéØ Exercice 2 : Rate Limiter

{% hint style="info" %}
**Cr√©ez un limiteur de taux d'appels :**
{% endhint %}

```javascript
// Cr√©ez creerRateLimiter(maxAppels, fen√™treTempsMsMs) qui retourne une fonction
// qui limite le nombre d'appels dans une fen√™tre de temps

// Utilisation :
const limiter = creerRateLimiter(5, 60000); // 5 appels max par minute

for (let i = 0; i < 8; i++) {
  const result = limiter(() => console.log(`Appel ${i + 1}`));
  if (!result) {
    console.log(`Appel ${i + 1} bloqu√© - limite atteinte`);
  }
}
```

<details>
<summary>üí° Solution</summary>

```javascript
function creerRateLimiter(maxAppels, fen√™treTemps) {
  let appels = [];
  
  return function(callback) {
    const maintenant = Date.now();
    
    // Nettoyer les appels expir√©s
    appels = appels.filter(temps => maintenant - temps < fen√™treTemps);
    
    if (appels.length >= maxAppels) {
      return false; // Limite atteinte
    }
    
    // Enregistrer cet appel
    appels.push(maintenant);
    
    // Ex√©cuter le callback
    if (typeof callback === 'function') {
      return callback();
    }
    
    return true;
  };
}

// Version avanc√©e avec multiple keys
function creerRateLimiterAvanc√©(maxAppels, fen√™treTemps) {
  const limites = new Map();
  
  return function(cl√©, callback) {
    if (!limites.has(cl√©)) {
      limites.set(cl√©, []);
    }
    
    const appels = limites.get(cl√©);
    const maintenant = Date.now();
    
    // Nettoyer les appels expir√©s pour cette cl√©
    const appelsValides = appels.filter(temps => maintenant - temps < fen√™treTemps);
    limites.set(cl√©, appelsValides);
    
    if (appelsValides.length >= maxAppels) {
      return false;
    }
    
    appelsValides.push(maintenant);
    limites.set(cl√©, appelsValides);
    
    if (typeof callback === 'function') {
      return callback();
    }
    
    return true;
  };
}
```

</details>

## üéØ Quiz de validation

{% hint style="info" %}
**Question 1 :** Que va afficher ce code ?
```javascript
function cr√©erFonctions() {
  const fns = [];
  for (let i = 0; i < 3; i++) {
    fns.push(() => i);
  }
  return fns;
}

const fonctions = cr√©erFonctions();
console.log(fonctions[0](), fonctions[1](), fonctions[2]());
```
{% endhint %}

<details>
<summary>üí° R√©ponse</summary>

**0 1 2**

Avec `let`, chaque it√©ration de la boucle cr√©e un nouveau scope de bloc. Chaque fonction arrow capture sa propre variable `i`.

Si c'√©tait `var`, le r√©sultat serait `3 3 3` car toutes les fonctions partageraient la m√™me variable `i`.

</details>

{% hint style="info" %}
**Question 2 :** Les closures peuvent-elles causer des fuites m√©moire ?
{% endhint %}

<details>
<summary>üí° R√©ponse</summary>

**Oui !** Les closures gardent des r√©f√©rences vers leur environnement lexical entier. Si une closure r√©f√©rence une grosse structure de donn√©es mais n'utilise qu'une petite partie, toute la structure reste en m√©moire.

**Solution :** Extraire seulement les donn√©es n√©cessaires avant de cr√©er la closure.

</details>

## üîó Liens avec d'autres concepts

{% content-ref url="../fonctions-avancees.md" %}
[fonctions-avancees.md](../fonctions-avancees.md)
{% endcontent-ref %}

{% content-ref url="../prototypes-heritage.md" %}
[prototypes-heritage.md](../prototypes-heritage.md)
{% endcontent-ref %}

{% content-ref url="../../niveau-avance/modules-organisation.md" %}
[modules-organisation.md](../../niveau-avance/modules-organisation.md)
{% endcontent-ref %}

## üöÄ Prochaines √©tapes

{% hint style="success" %}
**Maintenant que vous ma√Ætrisez les closures :**

üëâ **Explorez** les [Fonctions Avanc√©es](../fonctions-avancees.md)  
üëâ **D√©couvrez** les [Prototypes et H√©ritage](../prototypes-heritage.md)  
üëâ **Approfondissez** l'[Organisation en Modules](../../niveau-avance/modules-organisation.md)  
{% endhint %}

## üéØ R√©sum√©

{% hint style="info" %}
**Points cl√©s √† retenir :**

üîê **Closure = fonction + environnement lexical** captur√©  
üèóÔ∏è **Encapsulation** : Cr√©er des donn√©es priv√©es facilement  
üè≠ **Factory functions** : G√©n√©rer des fonctions sp√©cialis√©es  
‚ö†Ô∏è **Attention m√©moire** : Les closures gardent tout l'environnement  
üéØ **Lexical scope** : Port√©e d√©termin√©e par l'emplacement dans le code  
{% endhint %}

---

{% hint style="warning" %}
**Pr√™t pour la suite ?** Les closures sont la fondation des [Fonctions Avanc√©es](../fonctions-avancees.md) !
{% endhint %}
