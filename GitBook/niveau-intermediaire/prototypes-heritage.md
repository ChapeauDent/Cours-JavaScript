# üß¨ Prototypes et H√©ritage

{% hint style="info" %}
**Niveau :** üü° Interm√©diaire | **Dur√©e :** 50 min | **Pr√©requis :** Objets, Fonctions, Classes ES6
{% endhint %}

## üéØ Objectifs d'apprentissage

{% hint style="success" %}
√Ä la fin de cette le√ßon, vous serez capable de :
- [ ] **Comprendre** la cha√Æne prototypale et son fonctionnement
- [ ] **Diff√©rencier** h√©ritage prototypal vs h√©ritage classique
- [ ] **Manipuler** les prototypes et cr√©er des hi√©rarchies d'objets
- [ ] **D√©boguer** les probl√®mes li√©s aux prototypes
{% endhint %}

## üîë Concepts cl√©s

{% tabs %}
{% tab title="D√©finitions" %}
**Prototype** : Objet mod√®le dont h√©ritent d'autres objets  
**Cha√Æne prototypale** : Succession de prototypes jusqu'√† `null`  
**H√©ritage prototypal** : M√©canisme d'h√©ritage natif de JavaScript  
**Constructor function** : Fonction utilis√©e avec `new`  
**Prototype pollution** : Modification dangereuse des prototypes natifs  
{% endtab %}

{% tab title="Importance" %}
üèóÔ∏è **Base de tout** : Tous les objets JavaScript h√©ritent de prototypes  
üé≠ **Classes ES6** : Sont du "sucre syntaxique" sur les prototypes  
‚ö° **Performance** : M√©thodes partag√©es via prototypes  
üîÑ **Flexibilit√©** : Modification dynamique des "classes"  
üì± **Frameworks** : React, Vue utilisent massivement les prototypes  
{% endtab %}
{% endtabs %}

## üìñ Qu'est-ce qu'un prototype ?

{% hint style="warning" %}
**Concept cl√© :** Chaque objet JavaScript a un lien vers un autre objet appel√© son **prototype**. Si une propri√©t√© n'existe pas sur l'objet, JavaScript la cherche dans son prototype.
{% endhint %}

### üîç Exemple fondamental

{% tabs %}
{% tab title="H√©ritage simple" %}
```javascript
// Objet "parent"
const animal = {
  type: "animal",
  respirer() {
    console.log(`${this.nom || 'L\'animal'} respire`);
  },
  dormir() {
    console.log(`${this.nom || 'L\'animal'} dort`);
  }
};

// Objet "enfant"
const chien = {
  nom: "Rex",
  race: "Labrador"
};

// Cr√©er l'h√©ritage
Object.setPrototypeOf(chien, animal);

// Utilisation
console.log(chien.nom);    // "Rex" (propri√©t√© propre)
console.log(chien.type);   // "animal" (trouv√©e dans le prototype)
chien.respirer();          // "Rex respire" (m√©thode du prototype)
chien.dormir();            // "Rex dort"
```
{% endtab %}

{% tab title="V√©rification du prototype" %}
```javascript
// M√©thodes pour v√©rifier les prototypes
console.log(Object.getPrototypeOf(chien) === animal); // true
console.log(chien.__proto__ === animal); // true (d√©pr√©ci√©)
console.log(animal.isPrototypeOf(chien)); // true

// V√©rifier si une propri√©t√© est propre √† l'objet
console.log(chien.hasOwnProperty('nom'));    // true
console.log(chien.hasOwnProperty('type'));   // false (dans le prototype)

// Lister les propri√©t√©s propres
console.log(Object.getOwnPropertyNames(chien)); // ['nom', 'race']
```
{% endtab %}
{% endtabs %}

## ‚õìÔ∏è La cha√Æne prototypale

### üîó Comment √ßa fonctionne

{% hint style="info" %}
JavaScript remonte la cha√Æne des prototypes dans cet ordre :
1. **Objet lui-m√™me**
2. **Son prototype direct**
3. **Le prototype du prototype**
4. **Jusqu'√† `Object.prototype`**
5. **Puis `null`** (fin de cha√Æne)
{% endhint %}

{% tabs %}
{% tab title="Cha√Æne compl√®te" %}
```javascript
const grandParent = {
  famille: "Mammif√®res",
  anc√™tre() {
    return "Je suis l'anc√™tre";
  }
};

const parent = {
  famille: "Carnivores", // Masque la propri√©t√© du grand-parent
  chasseur: true
};

const enfant = {
  nom: "Loup",
  hurler() {
    return "Aouuuu!";
  }
};

// Cr√©er la cha√Æne : enfant ‚Üí parent ‚Üí grandParent ‚Üí Object.prototype ‚Üí null
Object.setPrototypeOf(parent, grandParent);
Object.setPrototypeOf(enfant, parent);

// Recherche dans la cha√Æne
console.log(enfant.nom);        // "Loup" (propri√©t√© propre)
console.log(enfant.chasseur);   // true (premier niveau parent)
console.log(enfant.famille);    // "Carnivores" (masque "Mammif√®res")
console.log(enfant.anc√™tre());  // "Je suis l'anc√™tre" (grand-parent)
console.log(enfant.toString()); // "[object Object]" (Object.prototype)
```
{% endtab %}

{% tab title="Visualisation de la cha√Æne" %}
```javascript
function afficherCha√ÆnePrototypale(obj, nom = "objet") {
  console.log(`\nüîç Cha√Æne prototypale de ${nom}:`);
  
  let current = obj;
  let niveau = 0;
  
  while (current !== null) {
    const constructorName = current.constructor?.name || "Unknown";
    const isBuiltIn = current === Object.prototype || 
                     current === Function.prototype ||
                     current === Array.prototype;
    
    console.log(`  ${"  ".repeat(niveau)}‚Üì ${isBuiltIn ? 'üîß' : 'üì¶'} ${constructorName}`);
    
    // Afficher les propri√©t√©s propres
    const props = Object.getOwnPropertyNames(current);
    const visibleProps = props.filter(p => 
      p !== 'constructor' && 
      typeof current[p] !== 'function'
    ).slice(0, 3); // Limiter l'affichage
    
    if (visibleProps.length > 0) {
      console.log(`  ${"  ".repeat(niveau + 1)}   ${visibleProps.join(', ')}`);
    }
    
    current = Object.getPrototypeOf(current);
    niveau++;
    
    if (niveau > 10) break; // S√©curit√©
  }
  
  console.log(`  ${"  ".repeat(niveau)}‚Üì null`);
}

// Test avec notre exemple
afficherCha√ÆnePrototypale(enfant, "enfant");
```
{% endtab %}
{% endtabs %}

## üèóÔ∏è Constructor Functions et Prototypes

### üé≠ L'approche "classique" de JavaScript

{% tabs %}
{% tab title="Constructor Function basique" %}
```javascript
// Constructor function (convention : PascalCase)
function Animal(nom, type) {
  // Propri√©t√©s d'instance
  this.nom = nom;
  this.type = type;
  this.√©nergie = 100;
}

// M√©thodes partag√©es via prototype
Animal.prototype.manger = function() {
  this.√©nergie += 10;
  console.log(`${this.nom} mange et a maintenant ${this.√©nergie} d'√©nergie`);
};

Animal.prototype.dormir = function() {
  this.√©nergie += 20;
  console.log(`${this.nom} dort et r√©cup√®re de l'√©nergie`);
};

Animal.prototype.info = function() {
  return `${this.nom} est un ${this.type} avec ${this.√©nergie} d'√©nergie`;
};

// Cr√©ation d'instances
const chat = new Animal("Miaou", "chat");
const chien = new Animal("Rex", "chien");

chat.manger(); // "Miaou mange et a maintenant 110 d'√©nergie"
chien.dormir(); // "Rex dort et r√©cup√®re de l'√©nergie"

console.log(chat.info()); // "Miaou est un chat avec 110 d'√©nergie"

// V√©rifications
console.log(chat instanceof Animal); // true
console.log(chat.constructor === Animal); // true
console.log(Object.getPrototypeOf(chat) === Animal.prototype); // true
```
{% endtab %}

{% tab title="H√©ritage avec constructor functions" %}
```javascript
// Constructor parent
function Animal(nom, type) {
  this.nom = nom;
  this.type = type;
  this.√©nergie = 100;
}

Animal.prototype.manger = function() {
  this.√©nergie += 10;
  return `${this.nom} mange`;
};

Animal.prototype.dormir = function() {
  this.√©nergie += 20;
  return `${this.nom} dort`;
};

// Constructor enfant
function Chien(nom, race) {
  // Appeler le constructor parent
  Animal.call(this, nom, "chien");
  this.race = race;
}

// Cr√©er l'h√©ritage prototypal
Chien.prototype = Object.create(Animal.prototype);
Chien.prototype.constructor = Chien; // Restaurer le constructor

// Ajouter des m√©thodes sp√©cifiques
Chien.prototype.aboyer = function() {
  console.log(`${this.nom} aboie: Woof! Woof!`);
  this.√©nergie -= 5;
};

Chien.prototype.manger = function() {
  // Surcharger la m√©thode parent
  const result = Animal.prototype.manger.call(this);
  console.log(`${result} (comme un bon chien)`);
  return result;
};

// Test
const labrador = new Chien("Buddy", "Labrador");
console.log(labrador.info()); // H√©rit√© d'Animal
labrador.aboyer(); // M√©thode sp√©cifique
labrador.manger(); // M√©thode surcharg√©e

// V√©rifications d'h√©ritage
console.log(labrador instanceof Chien); // true
console.log(labrador instanceof Animal); // true
console.log(labrador instanceof Object); // true
```
{% endtab %}
{% endtabs %}

## üé® Classes ES6 vs Prototypes

### üÜö Comparaison syntaxique

{% tabs %}
{% tab title="Avec Classes ES6" %}
```javascript
class Animal {
  constructor(nom, type) {
    this.nom = nom;
    this.type = type;
    this.√©nergie = 100;
  }
  
  manger() {
    this.√©nergie += 10;
    return `${this.nom} mange`;
  }
  
  dormir() {
    this.√©nergie += 20;
    return `${this.nom} dort`;
  }
  
  get info() {
    return `${this.nom} est un ${this.type} avec ${this.√©nergie} d'√©nergie`;
  }
  
  static esp√®ce() {
    return "√ätre vivant";
  }
}

class Chien extends Animal {
  constructor(nom, race) {
    super(nom, "chien");
    this.race = race;
  }
  
  aboyer() {
    console.log(`${this.nom} aboie: Woof!`);
    this.√©nergie -= 5;
  }
  
  manger() {
    const result = super.manger();
    console.log(`${result} (comme un bon chien)`);
    return result;
  }
}

const rex = new Chien("Rex", "Berger");
console.log(rex.info); // getter
rex.aboyer();
```
{% endtab %}

{% tab title="√âquivalent prototypal" %}
```javascript
// Exactement le m√™me comportement avec les prototypes
function Animal(nom, type) {
  this.nom = nom;
  this.type = type;
  this.√©nergie = 100;
}

Animal.prototype.manger = function() {
  this.√©nergie += 10;
  return `${this.nom} mange`;
};

Animal.prototype.dormir = function() {
  this.√©nergie += 20;
  return `${this.nom} dort`;
};

Object.defineProperty(Animal.prototype, 'info', {
  get: function() {
    return `${this.nom} est un ${this.type} avec ${this.√©nergie} d'√©nergie`;
  }
});

Animal.esp√®ce = function() {
  return "√ätre vivant";
};

function Chien(nom, race) {
  Animal.call(this, nom, "chien");
  this.race = race;
}

Chien.prototype = Object.create(Animal.prototype);
Chien.prototype.constructor = Chien;

Chien.prototype.aboyer = function() {
  console.log(`${this.nom} aboie: Woof!`);
  this.√©nergie -= 5;
};

Chien.prototype.manger = function() {
  const result = Animal.prototype.manger.call(this);
  console.log(`${result} (comme un bon chien)`);
  return result;
};

// R√©sultat identique !
const rex = new Chien("Rex", "Berger");
console.log(rex.info);
rex.aboyer();
```
{% endtab %}
{% endtabs %}

### üéØ Sous le capot

{% hint style="success" %}
**Les classes ES6 sont du "sucre syntaxique" !**

Elles g√©n√®rent exactement le m√™me code prototypal que l'approche traditionnelle, mais avec une syntaxe plus famili√®re pour les d√©veloppeurs venant d'autres langages.
{% endhint %}

```javascript
// Preuve que les classes utilisent les prototypes
class MaClasse {
  m√©thode() {
    return "test";
  }
}

const instance = new MaClasse();

console.log(typeof MaClasse); // "function" (pas "class"!)
console.log(MaClasse.prototype.m√©thode); // function m√©thode() { return "test"; }
console.log(instance.__proto__ === MaClasse.prototype); // true
```

## üîß M√©thodes avanc√©es de manipulation

### üõ†Ô∏è Object.create() et alternatives

{% tabs %}
{% tab title="Object.create()" %}
```javascript
// Object.create() : la m√©thode moderne recommand√©e
const animalPrototype = {
  init(nom, type) {
    this.nom = nom;
    this.type = type;
    this.√©nergie = 100;
    return this;
  },
  
  manger() {
    this.√©nergie += 10;
    console.log(`${this.nom} mange`);
  },
  
  info() {
    return `${this.nom} (${this.type}): ${this.√©nergie} √©nergie`;
  }
};

// Cr√©er des objets avec ce prototype
const chat = Object.create(animalPrototype).init("Miaou", "chat");
const chien = Object.create(animalPrototype).init("Rex", "chien");

chat.manger();
console.log(chat.info());

// Avec des propri√©t√©s suppl√©mentaires
const oiseau = Object.create(animalPrototype, {
  peutVoler: {
    value: true,
    writable: false,
    enumerable: true
  },
  altitude: {
    value: 0,
    writable: true
  }
});

oiseau.init("Tweety", "canari");
console.log(oiseau.peutVoler); // true
```
{% endtab %}

{% tab title="Factory Functions" %}
```javascript
// Pattern Factory avec prototypes
function cr√©erAnimal(nom, type, sp√©cialit√©s = {}) {
  // Prototype de base
  const animalProto = {
    manger() {
      this.√©nergie += 10;
      return this;
    },
    
    dormir() {
      this.√©nergie += 20;
      return this;
    },
    
    info() {
      return `${this.nom} (${this.type}): ${this.√©nergie} √©nergie`;
    }
  };
  
  // Cr√©er l'objet avec le prototype
  const animal = Object.create(animalProto);
  
  // Propri√©t√©s d'instance
  animal.nom = nom;
  animal.type = type;
  animal.√©nergie = 100;
  
  // Ajouter les sp√©cialit√©s
  Object.assign(animal, sp√©cialit√©s);
  
  return animal;
}

// Utilisation
const dauphin = cr√©erAnimal("Flipper", "dauphin", {
  nager() {
    console.log(`${this.nom} nage gracieusement`);
    this.√©nergie -= 5;
    return this;
  },
  
  saut() {
    console.log(`${this.nom} fait un saut spectaculaire!`);
    this.√©nergie -= 15;
    return this;
  }
});

// Cha√Ænage de m√©thodes
dauphin.nager().saut().manger().dormir();
console.log(dauphin.info());
```
{% endtab %}
{% endtabs %}

### üéõÔ∏è Mixins et composition

{% tabs %}
{% tab title="Syst√®me de Mixins" %}
```javascript
// Mixins : ajouter des comportements √† des objets
const Volant = {
  voler() {
    console.log(`${this.nom} vole dans le ciel`);
    this.√©nergie -= 10;
    return this;
  },
  
  atterrir() {
    console.log(`${this.nom} atterrit`);
    this.√©nergie -= 2;
    return this;
  }
};

const Nageur = {
  nager() {
    console.log(`${this.nom} nage`);
    this.√©nergie -= 5;
    return this;
  },
  
  plonger() {
    console.log(`${this.nom} plonge`);
    this.√©nergie -= 8;
    return this;
  }
};

const Terrestre = {
  courir() {
    console.log(`${this.nom} court`);
    this.√©nergie -= 7;
    return this;
  },
  
  marcher() {
    console.log(`${this.nom} marche`);
    this.√©nergie -= 3;
    return this;
  }
};

// Fonction pour appliquer des mixins
function appliquerMixins(target, ...mixins) {
  mixins.forEach(mixin => {
    Object.assign(target.prototype || target, mixin);
  });
  return target;
}

// Cr√©er des animaux sp√©cialis√©s
function Canard(nom) {
  this.nom = nom;
  this.type = "canard";
  this.√©nergie = 100;
}

// Le canard peut voler, nager ET marcher
appliquerMixins(Canard, Volant, Nageur, Terrestre);

const donald = new Canard("Donald");
donald.nager().voler().atterrir().marcher();
console.log(`√ânergie restante: ${donald.√©nergie}`);
```
{% endtab %}

{% tab title="Composition avanc√©e" %}
```javascript
// Syst√®me de composition plus sophistiqu√©
class CompositeBuilder {
  constructor() {
    this.behaviors = new Map();
  }
  
  addBehavior(name, behavior) {
    this.behaviors.set(name, behavior);
    return this;
  }
  
  compose(target) {
    for (const [name, behavior] of this.behaviors) {
      if (typeof behavior === 'function') {
        target[name] = behavior.bind(target);
      } else if (typeof behavior === 'object') {
        Object.assign(target, behavior);
      }
    }
    return target;
  }
  
  createFactory(baseProps = {}) {
    return (props = {}) => {
      const instance = Object.assign({}, baseProps, props);
      return this.compose(instance);
    };
  }
}

// D√©finir des comportements
const builder = new CompositeBuilder()
  .addBehavior('parler', function(message) {
    console.log(`${this.nom} dit: "${message}"`);
    return this;
  })
  .addBehavior('manger', function() {
    this.faim = Math.max(0, this.faim - 20);
    console.log(`${this.nom} mange. Faim: ${this.faim}`);
    return this;
  })
  .addBehavior('repos', function() {
    this.fatigue = Math.max(0, this.fatigue - 30);
    console.log(`${this.nom} se repose. Fatigue: ${this.fatigue}`);
    return this;
  });

// Cr√©er une factory
const cr√©erPersonnage = builder.createFactory({
  faim: 50,
  fatigue: 30,
  humeur: "neutre"
});

// Utilisation
const h√©ros = cr√©erPersonnage({ nom: "Gandalf", type: "magicien" });
h√©ros.parler("Tu ne passeras pas!")
     .manger()
     .repos()
     .parler("Maintenant je me sens mieux");

console.log(h√©ros);
```
{% endtab %}
{% endtabs %}

## ‚ö†Ô∏è Pi√®ges et bonnes pratiques

### üö® Erreurs communes

{% tabs %}
{% tab title="Modification des prototypes natifs" %}
```javascript
// ‚ùå DANGEREUX : Ne jamais modifier les prototypes natifs
Array.prototype.dernier√âl√©ment = function() {
  return this[this.length - 1];
};

// ‚ùå Cela peut casser d'autres librairies
String.prototype.inverser = function() {
  return this.split('').reverse().join('');
};

// ‚úÖ Bonnes alternatives :
function obtenirDernier√âl√©ment(arr) {
  return arr[arr.length - 1];
}

function inverserCha√Æne(str) {
  return str.split('').reverse().join('');
}

// ‚úÖ Ou cr√©er vos propres classes
class MonArray extends Array {
  get dernier√âl√©ment() {
    return this[this.length - 1];
  }
}

const arr = new MonArray(1, 2, 3);
console.log(arr.dernier√âl√©ment); // 3
```
{% endtab %}

{% tab title="Probl√®mes avec 'this'" %}
```javascript
function Animal(nom) {
  this.nom = nom;
}

Animal.prototype.pr√©senter = function() {
  return `Je suis ${this.nom}`;
};

const chat = new Animal("Miaou");

// ‚ùå Probl√®me : perte du contexte 'this'
const pr√©sentation = chat.pr√©senter;
console.log(pr√©sentation()); // "Je suis undefined"

// ‚úÖ Solutions :
// 1. bind()
const pr√©sentationLi√©e = chat.pr√©senter.bind(chat);
console.log(pr√©sentationLi√©e()); // "Je suis Miaou"

// 2. Arrow function dans un wrapper
const wrapper = () => chat.pr√©senter();
console.log(wrapper()); // "Je suis Miaou"

// 3. call() ou apply()
console.log(chat.pr√©senter.call(chat)); // "Je suis Miaou"

// ‚úÖ Pattern moderne : m√©thodes avec arrow functions
function ModernAnimal(nom) {
  this.nom = nom;
  
  // Arrow function lie automatiquement 'this'
  this.pr√©senter = () => {
    return `Je suis ${this.nom}`;
  };
}

const chienModerne = new ModernAnimal("Rex");
const pr√©s = chienModerne.pr√©senter;
console.log(pr√©s()); // "Je suis Rex" ‚úÖ
```
{% endtab %}

{% tab title="Performance et m√©moire" %}
```javascript
// ‚ùå M√©thodes dans le constructor (dupliqu√©es)
function AnimalInefficient(nom) {
  this.nom = nom;
  
  // Chaque instance a sa propre copie de ces m√©thodes !
  this.manger = function() {
    console.log(`${this.nom} mange`);
  };
  
  this.dormir = function() {
    console.log(`${this.nom} dort`);
  };
}

// ‚úÖ M√©thodes dans le prototype (partag√©es)
function AnimalEfficient(nom) {
  this.nom = nom;
}

AnimalEfficient.prototype.manger = function() {
  console.log(`${this.nom} mange`);
};

AnimalEfficient.prototype.dormir = function() {
  console.log(`${this.nom} dort`);
};

// Test de performance
console.time("Inefficient");
const animauxInefficients = [];
for (let i = 0; i < 10000; i++) {
  animauxInefficients.push(new AnimalInefficient(`Animal${i}`));
}
console.timeEnd("Inefficient");

console.time("Efficient");
const animauxEfficients = [];
for (let i = 0; i < 10000; i++) {
  animauxEfficients.push(new AnimalEfficient(`Animal${i}`));
}
console.timeEnd("Efficient");

// V√©rification m√©moire
console.log("Premi√®re m√©thode m√™me r√©f√©rence:", 
  animauxEfficients[0].manger === animauxEfficients[1].manger); // true

console.log("Deuxi√®me m√©thode m√™me r√©f√©rence:", 
  animauxInefficients[0].manger === animauxInefficients[1].manger); // false
```
{% endtab %}
{% endtabs %}

## üß™ Exercices pratiques

### üéØ Exercice 1 : Syst√®me de v√©hicules

{% hint style="info" %}
**Cr√©ez une hi√©rarchie de v√©hicules avec prototypes :**
{% endhint %}

```javascript
// Cr√©ez :
// - Vehicule (classe de base)
// - Voiture, Moto (h√©ritent de Vehicule)
// - VoitureElectrique (h√©rite de Voiture)
// 
// Propri√©t√©s : marque, mod√®le, ann√©e, carburant, autonomie
// M√©thodes : d√©marrer(), arr√™ter(), rouler(distance), faireLePlein()

// Utilisation attendue :
const tesla = new VoitureElectrique("Tesla", "Model 3", 2023);
tesla.d√©marrer();
tesla.rouler(100);
tesla.recharger(); // M√©thode sp√©cifique aux √©lectriques
```

<details>
<summary>üí° Solution</summary>

```javascript
// Classe de base Vehicule
function Vehicule(marque, mod√®le, ann√©e) {
  this.marque = marque;
  this.mod√®le = mod√®le;
  this.ann√©e = ann√©e;
  this.enMarche = false;
  this.kilom√©trage = 0;
}

Vehicule.prototype.d√©marrer = function() {
  if (!this.enMarche) {
    this.enMarche = true;
    console.log(`${this.marque} ${this.mod√®le} a d√©marr√©`);
  } else {
    console.log("Le v√©hicule est d√©j√† en marche");
  }
  return this;
};

Vehicule.prototype.arr√™ter = function() {
  if (this.enMarche) {
    this.enMarche = false;
    console.log(`${this.marque} ${this.mod√®le} s'est arr√™t√©`);
  } else {
    console.log("Le v√©hicule est d√©j√† arr√™t√©");
  }
  return this;
};

Vehicule.prototype.rouler = function(distance) {
  if (!this.enMarche) {
    console.log("D√©marrez d'abord le v√©hicule!");
    return this;
  }
  
  this.kilom√©trage += distance;
  console.log(`A roul√© ${distance}km. Kilom√©trage total: ${this.kilom√©trage}km`);
  return this;
};

Vehicule.prototype.info = function() {
  return `${this.marque} ${this.mod√®le} (${this.ann√©e}) - ${this.kilom√©trage}km`;
};

// Voiture
function Voiture(marque, mod√®le, ann√©e, typeCarburant = "essence") {
  Vehicule.call(this, marque, mod√®le, ann√©e);
  this.typeCarburant = typeCarburant;
  this.r√©servoir = 50; // litres
  this.consommation = 7; // L/100km
}

Voiture.prototype = Object.create(Vehicule.prototype);
Voiture.prototype.constructor = Voiture;

Voiture.prototype.faireLePlein = function() {
  this.r√©servoir = 50;
  console.log(`${this.marque} ${this.mod√®le} a fait le plein`);
  return this;
};

Voiture.prototype.rouler = function(distance) {
  if (!this.enMarche) {
    console.log("D√©marrez d'abord le v√©hicule!");
    return this;
  }
  
  const carburantN√©cessaire = (distance * this.consommation) / 100;
  
  if (carburantN√©cessaire > this.r√©servoir) {
    console.log("Pas assez de carburant!");
    return this;
  }
  
  this.r√©servoir -= carburantN√©cessaire;
  this.kilom√©trage += distance;
  console.log(`A roul√© ${distance}km. Carburant restant: ${this.r√©servoir.toFixed(1)}L`);
  return this;
};

// Voiture √âlectrique
function VoitureElectrique(marque, mod√®le, ann√©e) {
  Voiture.call(this, marque, mod√®le, ann√©e, "√©lectrique");
  this.batterie = 100; // %
  this.autonomie = 400; // km
  this.consommationElectrique = 15; // kWh/100km
}

VoitureElectrique.prototype = Object.create(Voiture.prototype);
VoitureElectrique.prototype.constructor = VoitureElectrique;

VoitureElectrique.prototype.recharger = function() {
  this.batterie = 100;
  console.log(`${this.marque} ${this.mod√®le} est recharg√©e √† 100%`);
  return this;
};

VoitureElectrique.prototype.rouler = function(distance) {
  if (!this.enMarche) {
    console.log("D√©marrez d'abord le v√©hicule!");
    return this;
  }
  
  const batterieN√©cessaire = (distance / this.autonomie) * 100;
  
  if (batterieN√©cessaire > this.batterie) {
    console.log("Batterie insuffisante!");
    return this;
  }
  
  this.batterie -= batterieN√©cessaire;
  this.kilom√©trage += distance;
  console.log(`A roul√© ${distance}km. Batterie: ${this.batterie.toFixed(1)}%`);
  return this;
};

// Test
const tesla = new VoitureElectrique("Tesla", "Model 3", 2023);
tesla.d√©marrer()
     .rouler(100)
     .rouler(200)
     .recharger()
     .rouler(150);

console.log(tesla.info());
```

</details>

### üéØ Exercice 2 : Plugin System

{% hint style="info" %}
**Cr√©ez un syst√®me de plugins extensible :**
{% endhint %}

```javascript
// Cr√©ez un syst√®me o√π :
// - Une classe de base App peut √™tre √©tendue avec des plugins
// - Les plugins ajoutent des m√©thodes et propri√©t√©s
// - Les plugins peuvent d√©pendre d'autres plugins
// - On peut activer/d√©sactiver des plugins dynamiquement

// Utilisation attendue :
const app = new App();
app.use(Logger);
app.use(Database, { host: 'localhost' });
app.use(Router);

app.log('Application d√©marr√©e');
app.route('/api', handler);
```

<details>
<summary>üí° Solution</summary>

```javascript
// Syst√®me de plugins avanc√©
class App {
  constructor() {
    this.plugins = new Map();
    this.pluginInstances = new Map();
    this.hooks = new Map();
    this.config = {};
  }
  
  use(PluginClass, options = {}) {
    const pluginName = PluginClass.pluginName || PluginClass.name;
    
    // V√©rifier les d√©pendances
    if (PluginClass.dependencies) {
      for (const dep of PluginClass.dependencies) {
        if (!this.plugins.has(dep)) {
          throw new Error(`Plugin ${pluginName} requires ${dep}`);
        }
      }
    }
    
    // Cr√©er l'instance du plugin
    const plugin = new PluginClass(this, options);
    
    // Enregistrer
    this.plugins.set(pluginName, PluginClass);
    this.pluginInstances.set(pluginName, plugin);
    
    // Installer les m√©thodes du plugin
    if (plugin.install) {
      plugin.install();
    }
    
    // D√©clencher le hook d'installation
    this.triggerHook('plugin:installed', pluginName);
    
    console.log(`Plugin ${pluginName} install√©`);
    return this;
  }
  
  hasPlugin(name) {
    return this.plugins.has(name);
  }
  
  getPlugin(name) {
    return this.pluginInstances.get(name);
  }
  
  removePlugin(name) {
    const plugin = this.pluginInstances.get(name);
    if (plugin && plugin.uninstall) {
      plugin.uninstall();
    }
    
    this.plugins.delete(name);
    this.pluginInstances.delete(name);
    this.triggerHook('plugin:removed', name);
  }
  
  // Syst√®me de hooks
  addHook(event, callback) {
    if (!this.hooks.has(event)) {
      this.hooks.set(event, []);
    }
    this.hooks.get(event).push(callback);
  }
  
  triggerHook(event, ...args) {
    const callbacks = this.hooks.get(event) || [];
    callbacks.forEach(callback => callback(...args));
  }
}

// Plugin Logger
class Logger {
  static pluginName = 'Logger';
  
  constructor(app, options = {}) {
    this.app = app;
    this.level = options.level || 'info';
    this.prefix = options.prefix || '[LOG]';
  }
  
  install() {
    // Ajouter les m√©thodes √† l'app
    this.app.log = (message, level = 'info') => {
      if (this.shouldLog(level)) {
        console.log(`${this.prefix} [${level.toUpperCase()}] ${message}`);
      }
    };
    
    this.app.error = (message) => this.app.log(message, 'error');
    this.app.warn = (message) => this.app.log(message, 'warn');
    this.app.info = (message) => this.app.log(message, 'info');
    this.app.debug = (message) => this.app.log(message, 'debug');
  }
  
  shouldLog(level) {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    return levels[level] >= levels[this.level];
  }
  
  uninstall() {
    delete this.app.log;
    delete this.app.error;
    delete this.app.warn;
    delete this.app.info;
    delete this.app.debug;
  }
}

// Plugin Database
class Database {
  static pluginName = 'Database';
  static dependencies = ['Logger'];
  
  constructor(app, options = {}) {
    this.app = app;
    this.host = options.host || 'localhost';
    this.port = options.port || 5432;
    this.connected = false;
  }
  
  install() {
    this.app.db = {
      connect: () => this.connect(),
      query: (sql) => this.query(sql),
      disconnect: () => this.disconnect()
    };
  }
  
  connect() {
    this.connected = true;
    this.app.log(`Connected to database at ${this.host}:${this.port}`);
    return Promise.resolve();
  }
  
  query(sql) {
    if (!this.connected) {
      this.app.error('Database not connected');
      return Promise.reject(new Error('Not connected'));
    }
    this.app.debug(`Executing query: ${sql}`);
    return Promise.resolve({ rows: [], affected: 0 });
  }
  
  disconnect() {
    this.connected = false;
    this.app.log('Disconnected from database');
  }
  
  uninstall() {
    this.disconnect();
    delete this.app.db;
  }
}

// Plugin Router
class Router {
  static pluginName = 'Router';
  static dependencies = ['Logger'];
  
  constructor(app, options = {}) {
    this.app = app;
    this.routes = new Map();
  }
  
  install() {
    this.app.route = (path, handler) => this.addRoute(path, handler);
    this.app.handleRequest = (path) => this.handleRequest(path);
  }
  
  addRoute(path, handler) {
    this.routes.set(path, handler);
    this.app.log(`Route registered: ${path}`);
  }
  
  handleRequest(path) {
    const handler = this.routes.get(path);
    if (handler) {
      this.app.log(`Handling request: ${path}`);
      return handler();
    } else {
      this.app.warn(`Route not found: ${path}`);
      return null;
    }
  }
  
  uninstall() {
    delete this.app.route;
    delete this.app.handleRequest;
  }
}

// Test du syst√®me
const app = new App();

try {
  app.use(Logger, { level: 'debug' })
     .use(Database, { host: 'localhost', port: 5432 })
     .use(Router);
  
  app.log('Application started');
  app.route('/api/users', () => 'Users data');
  app.route('/api/posts', () => 'Posts data');
  
  app.db.connect().then(() => {
    app.handleRequest('/api/users');
    app.handleRequest('/api/unknown');
  });
  
} catch (error) {
  console.error('Plugin error:', error.message);
}
```

</details>

## üéØ Quiz de validation

{% hint style="info" %}
**Question 1 :** Quelle est la diff√©rence entre `__proto__` et `prototype` ?
{% endhint %}

<details>
<summary>üí° R√©ponse</summary>

**`__proto__`** : Propri√©t√© de **chaque objet** qui pointe vers son prototype  
**`prototype`** : Propri√©t√© des **fonctions** utilis√©e pour cr√©er le prototype des instances

```javascript
function Personne() {}
const alice = new Personne();

// alice.__proto__ === Personne.prototype (true)
// alice.prototype === undefined (les objets n'ont pas 'prototype')
// Personne.__proto__ === Function.prototype (true)
```

</details>

{% hint style="info" %}
**Question 2 :** Pourquoi √©viter de modifier les prototypes natifs ?
{% endhint %}

<details>
<summary>üí° R√©ponse</summary>

**Risques :**
- üî• **Conflits** avec d'autres librairies
- üêõ **Comportement impr√©visible** du code existant
- üö´ **Standards** : violation des bonnes pratiques
- üîÑ **√âvolution** : les futures versions JS peuvent ajouter ces m√©thodes

**Alternative :** Cr√©er vos propres classes ou fonctions utilitaires.

</details>

## üîó Liens avec d'autres concepts

{% content-ref url="../closures-lexical-scope.md" %}
[closures-lexical-scope.md](../closures-lexical-scope.md)
{% endcontent-ref %}

{% content-ref url="../classes-poo.md" %}
[classes-poo.md](../classes-poo.md)
{% endcontent-ref %}

{% content-ref url="../../niveau-avance/design-patterns.md" %}
[design-patterns.md](../../niveau-avance/design-patterns.md)
{% endcontent-ref %}

## üöÄ Prochaines √©tapes

{% hint style="success" %}
**Maintenant que vous ma√Ætrisez les prototypes :**

üëâ **Approfondissez** les [Classes et POO](../classes-poo.md)  
üëâ **Explorez** les [Design Patterns](../../niveau-avance/design-patterns.md)  
üëâ **D√©couvrez** les [Modules et Organisation](../../niveau-avance/modules-organisation.md)  
{% endhint %}

## üéØ R√©sum√©

{% hint style="info" %}
**Points cl√©s √† retenir :**

üß¨ **Prototypes = base de JavaScript** - tout objet h√©rite d'un prototype  
‚õìÔ∏è **Cha√Æne prototypale** - recherche des propri√©t√©s en remontant  
üé≠ **Classes ES6 = sucre syntaxique** sur les prototypes  
üèóÔ∏è **Constructor functions** - approche classique pour cr√©er des "classes"  
‚ö†Ô∏è **Ne jamais modifier** les prototypes natifs  
{% endhint %}

---

{% hint style="warning" %}
**Pr√™t pour la suite ?** Les prototypes sont la fondation des [Classes et de la POO](../classes-poo.md) !
{% endhint %}
